<예외처리>
스프링MVC 사용시 Controller에서 Exception 처리를 위한 방법
 - @ExceptionHandler 이용하는 방식 
 - @ControllerAdvice 이용하는 방식 : 대체로 이 방식을 사용
 - @ResponseStatus 이용한 http상태코드 처리 방식
 
 
 @ControllerAdvice : 공통의 Exception 처리 전용 객체를 사용
  - 컨트롤러에 @ControllerAdvice 어노테이션 
  - 각 메소드에 @ExceptionHandler를 이용해서 적절한 타입의 Exception 처리
 
 ------------------------------------------------------------------------------------------------------ 

<페이징처리>
 - endPage = Math.ceil((현재 페이지번호/총 페이지 수) * 총 페이지 수)
 - startPage = (endPage - 총 페이지 수) + 1
 
 //마지막 페이지의 글 수가 총 페이지 수 보다 작을 경우 endPage
 - finalEndPage =  Math.ceil(total 글 수/페이지당 글 수)
 - endPage : if(endPage > finalEndPage) { endPage = finalEndPage } 
 
 - prev = (startPage == 1) ? false : true;
 - next = (endPage * 페이지당 글 수 >= totalData) ? false : true
 
 ------------------------------------------------------------------------------------------------------
 
<컨트롤러 매개변수> 
 @RequestParam
 - HTTP 요청 파라미터를 메소드 파라미터에 넣어 주는 애노테이션
 - 어노테이션 생략 가능. 이 때는 메소드 파라미터와 같은 이름의 요청 파라미터 값을 받는다.
 - 참고사이트 : http://springsource.tistory.com/13
 
 @ModelAttribute
 - 클라이언트로부터 컨트롤러가 받은 요청정보 중에서, 하나 이상의 값을 가진, 오브젝트 형태로 만들 수 있는 구조적인 정보를 @ModelAttribute 모델이라고 부른다.
 - 단지 요청 파라미터를 메소드 파라미터에서 1:1로 받으면 @RequestParam 이고, 도메인 오브젝트나 DTO 의 프로퍼티에 요청 파라미터를 바인딩해서 한번에 받으면 @ModelAttribute 라고 볼 수 있다. 
 - 컨트롤러가 리턴하는 모델에 파라미터로 전달한 오브젝트를 자동으로 추가. 모델의 이름은 기본적으로 파라미터의 이름을 따른다. 다른 이름을 사용하고 싶다면 (@ModelAttribute("원하는이름지정") User user)와 같이 사용
 - 어노테이션 생략 가능 : @RequestParam, @ModelAttribute 애노테이션을 사용하면 메소드 선언이 길어지고 복잡해 보인다고 이를 무조건 생략하는 건 위험할 수 있다. 
 	public String save(@ModelAttribute User user){ ... }  == public String save(User user){ ... }
 
 Map/Model/ModelMap
 - 다른 애노테이션이 붙어 있지 않다면 java.util.Map 그리고 스프링의 org.springframework.ui.Model/ModelMap 타입의 파라미터는 모두 모델 정보를 담는 데 사용할 수 있는 오브젝트가 전달된다. 
 - 모델을 담을 맵은 메소드 내에서 직접 생성할 수도 있지만 그보다는 파라미터로 정의해서 핸들러 어댑터에서 미리 만들어 제공해주는 것을 사용하면 편리