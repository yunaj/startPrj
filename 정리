//Shorthand for $( document ).ready()
$(function() {
    console.log( "ready!" );
});


<예외처리>
스프링MVC 사용시 Controller에서 Exception 처리를 위한 방법
 - @ExceptionHandler 이용하는 방식 
 - @ControllerAdvice 이용하는 방식 : 대체로 이 방식을 사용
 - @ResponseStatus 이용한 http상태코드 처리 방식
 
 
 @ControllerAdvice : 공통의 Exception 처리 전용 객체를 사용
  - 컨트롤러에 @ControllerAdvice 어노테이션 
  - 각 메소드에 @ExceptionHandler를 이용해서 적절한 타입의 Exception 처리
 
 ------------------------------------------------------------------------------------------------------ 

<페이징처리>
 - endPage = Math.ceil((현재 페이지번호/총 페이지 수) * 총 페이지 수)
 - startPage = (endPage - 총 페이지 수) + 1
 
 //마지막 페이지의 글 수가 총 페이지 수 보다 작을 경우 endPage
 - finalEndPage =  Math.ceil(total 글 수/페이지당 글 수)
 - endPage : if(endPage > finalEndPage) { endPage = finalEndPage } 
 
 - prev = (startPage == 1) ? false : true;
 - next = (endPage * 페이지당 글 수 >= totalData) ? false : true
 
 ------------------------------------------------------------------------------------------------------
 
<컨트롤러 매개변수> 
 @RequestParam
 - HTTP 요청 파라미터를 메소드 파라미터에 넣어 주는 애노테이션
 - 어노테이션 생략 가능. 이 때는 메소드 파라미터와 같은 이름의 요청 파라미터 값을 받는다.
 - 참고사이트 : http://springsource.tistory.com/13
 
 @ModelAttribute
 - 클라이언트로부터 컨트롤러가 받은 요청정보 중에서, 하나 이상의 값을 가진, 오브젝트 형태로 만들 수 있는 구조적인 정보를 @ModelAttribute 모델이라고 부른다.
 - 단지 요청 파라미터를 메소드 파라미터에서 1:1로 받으면 @RequestParam 이고, 도메인 오브젝트나 DTO 의 프로퍼티에 요청 파라미터를 바인딩해서 한번에 받으면 @ModelAttribute 라고 볼 수 있다. 
 - 컨트롤러가 리턴하는 모델에 파라미터로 전달한 오브젝트를 자동으로 추가. 모델의 이름은 기본적으로 파라미터의 이름을 따른다. 다른 이름을 사용하고 싶다면 (@ModelAttribute("원하는이름지정") User user)와 같이 사용
 - 어노테이션 생략 가능 : @RequestParam, @ModelAttribute 애노테이션을 사용하면 메소드 선언이 길어지고 복잡해 보인다고 이를 무조건 생략하는 건 위험할 수 있다. 
 	public String save(@ModelAttribute User user){ ... }  == public String save(User user){ ... }
 
 Map/Model/ModelMap
 - 다른 애노테이션이 붙어 있지 않다면 java.util.Map 그리고 스프링의 org.springframework.ui.Model/ModelMap 타입의 파라미터는 모두 모델 정보를 담는 데 사용할 수 있는 오브젝트가 전달된다. 
 - 모델을 담을 맵은 메소드 내에서 직접 생성할 수도 있지만 그보다는 파라미터로 정의해서 핸들러 어댑터에서 미리 만들어 제공해주는 것을 사용하면 편리
 
 -----------------------------------------------------------------------------------------------------------------
 
 <SOAP vs REST>
 * SOA(서비스지향 아키텍쳐) vs ROA(자원지향 아키텍쳐)
 - SOAP기반의 웹서비스는 SOA구조에 따라서 UDDI레지스트리를 통해서 웹서비스를 등록하고, 탐색하고 바인딩해서 이용
    상호 통신간 프로그램들이 잘 이해할 수 있는 문법에 따라 개발되었고, 그에 따라 개발자들은 웹서비스의 기본 스펙을 알아야하는 고난이도 프로그래밍 능력이 요구됨
   사람보다는 기계의 우선적으로 이해하기 쉬운 구조이므로 환경설정 및 개발환경이 준비되어야 함(동작과 프로세싱 중심)
    
 - RESTful웹서비스는 리소스를 등록하고 저장하는 중간 매개체 없이 리소스 제공자가 직접 요청자에게 제공
   인터넷서비스 업체들이 응용개발자들에 손쉬운 데이터 제공을 목적으로 출발
   기계보다는 사람이 이해하기 쉽도록 인터넷 기본(HTTP/XML)이외에 별도의 개발/실행 환경이 필요 없음
 
 1. SOAP : HTTP, HTTPS, SMTP등을 통해서 XML기반의 메세지를 컴퓨터 네트워크상에서 교환하는 프로토콜
 - SOAP기반의 웹서비스 장점 : 동적바인딩 가능, 독립된 모듈, 느슨한 서비스 연결, 서비스 조립이 가능, 플랫폼 무관
 - SOAP기반의 웹서비스 단점 : HTTP상에서 전송하기에 무겁다, 개발난이도가 높다
 - SOA : 해당서비스를 서로 조합해서 업무기능을 구현한 어플리케이션ㅇ르 만들어내는 소프트웨어 아키텍쳐
 - 모든 데이터가 XML로 표현됨
 - UDDI(Universal Description Discovery and Integration) 
  : 웹서비스를 등록하고 검색하기위한 저장소로 웹서비스를 공적으로 접근, 검색이 가능하도록 한 공개된 레지스트리
 - WSDL(Web Service Description Language)
  ex) <definitions>
  		<types>
  			데이터타입선언
  		</types>
  		<message>
  			메서드의 인자와 리턴값 선언
  		</message>
  		<portType>
  			인터페이스 정의
  			<operation>메서드 선언</operation>
  		</portType>
  		<binding>
  			실제 네트우크 프로토콜과 portType 매핑
  		</binding>
  		<service>
  			서비스정의(Endpoint)
  			<port> 웹서비스 URL </port>
  		</service>
  	   </definitions>
 
 2. REST
 - Roy Fielding이 웹 아키텍쳐가 웹의 본래 설계의 우수성을 활용하지 못함을 지적하고 웹의 장점을 최대한 활용할 수 있는 
      네트워크 기반의 아키텍쳐를 제안한 것
 - HTTP프로토콜로 데이터를 전달하는 프레임워크
 - 클라이언트와 서버간의 구성요소를 엄격하게 분리하여 구현을 단순화함
 - 핵심은 Web에 개방된 리소스 이용
 - REST는 웹에 개방된 리소스들을 원격에서 또는 로컬에서 쉽게 이용할 수 있는 웹 응용을 정착
 - REST 아키텍쳐 스타일에 따라 정의되고 이용되는 서비스나 응용프로그램을 RESTful 웹 서비스라고 함
  
-----------------------------------------------------------------------------------------------------------------

<HTTP 상태코드>
1. 100번대 
 - 100 : 데이터의 일부를 서버가 받은 상태(처리중인 상태)
 
2. 200번대 : 정상적인 처리 후 응답
 - 200 : 에러없이 정상처리
 - 204 : 정상처리 되었으나, 서버에 보낼 데이터가 없음

3. 300번대 : 다른 URL 처리
 - 301 : 요청한 URL이 새로 변경되었음
 - 304 : 기존의 데이터와 변경된 것이 없음
 
4. 400번대
 - 400 : 요청에 문제가 있기 때문에 서버에서 인식할 수 없음
 - 403 : 서버에서 허락되지 않음
 - 404 : 요청URL을 찾을 수 없음
 - 406 : 전송방식이 허락되지 않음(REST방식ㅇ서 자주 나타남)
 
5. 500번대
 - 500 : 서버에서 처리시 문제가 발생(프로그램 내부적인 오류)
 - 502 : 게이트웨이, 프록시 상태의 문제(과부하)
 - 503 : 일시적인 서비스 중단 상태
 - 504 : 지정된 처리시간이 지나서 처리되지 못하는 경우

-----------------------------------------------------------------------------------------------------------------

<AJAX>
동적 웹 어플리케이션을 구현하는데 필요한 기술
1. 장점
- 비동기방식으로 페이지 새로고침 없이 받은 데이터를 가공하여 표시
- 갱신시킬 페이지에 소량의 데이터블록만 서버로부터 수신하기 때문에 서버및 네티워크 부하 경감

2. REST와 AJAX
- REST + AJAX 방식을 이용한 웹앱 제작이 최근 대세
- REST는 데이터를 리턴(호출)하고, 사용하는 방식으로 AJAX는 그 데이터를 이용하는 방식

-----------------------------------------------------------------------------------------------------------------

 